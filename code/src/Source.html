<!DOCTYPE html><html lang="en"><head><title>src/Source</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/Source"><meta name="groc-project-path" content="src/Source.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Source.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Copyright 2019 Ulrich Gaal</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<pre><code>http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<h1 id="source">Source</h1></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> React, {
  useRef,
  useCallback,
  useEffect,
  useReducer,
  useMemo,
  useContext
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>
<span class="hljs-keyword">import</span> { SourceConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'./prop-types'</span>
<span class="hljs-keyword">import</span> { mergeObjects, log } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>
<span class="hljs-keyword">import</span> Location <span class="hljs-keyword">from</span> <span class="hljs-string">'./Location'</span>
<span class="hljs-keyword">import</span> { ConfigContext, StorageContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Contexts'</span>
<span class="hljs-keyword">import</span> {
  sourceInit,
  sourceReducer,
  MOUSE_OVER,
  MOUSE_MOVE,
  MOUSE_OUT,
  PIN,
  RESET,
  DISABLE
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers/sourceReducer'</span>
<span class="hljs-keyword">import</span> { storageReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers/storageReducer'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>Source</code> component acts as a wrapper for other components and enables them
to provide tips.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> Source = props =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Merge the context and local configs and extract relevant
properties from it</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> { id, config: localConfig, pinned, disabled } = props
  <span class="hljs-keyword">const</span> contextConfig = useContext(ConfigContext)
  <span class="hljs-keyword">const</span> config = useMemo(() =&gt; {
    <span class="hljs-keyword">return</span> mergeObjects(contextConfig, localConfig)
  }, [contextConfig, localConfig])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A <code>Source</code> can exist either in isolation (in which case it has
its own <code>Engine</code>), or within a <code>Storage</code> (in which case it shares
an <code>Engine</code> with its <code>Storage</code>).</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> useStorageReducer = useContext(StorageContext)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Most computations are delegated to a reducer.
The source transforms DOM events into actions and the
reducer computes changes to the state of the <code>Source</code>
(updates on position, location or visibility)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> [state, dispatch] = useStorageReducer
    ? useStorageReducer({ id, config })
    : useReducer(sourceReducer, { config }, sourceInit)
  log(<span class="hljs-string">'Source'</span>, <span class="hljs-number">0</span>, props, state)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Keep a reference to the actual <code>Source</code> DOM element,
used for tip positionning when target === false</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-literal">null</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Reinitialize the source if the config changes</p></div></div><div class="code"><div class="wrapper">  useEffect(() =&gt; {
    <span class="hljs-keyword">if</span> (config !== state.config) {
      dispatch({ type: RESET, config })
    }
  }, [config])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Make the source visible if the pinned property is set</p></div></div><div class="code"><div class="wrapper">  useEffect(() =&gt; {
    <span class="hljs-keyword">if</span> (state.pinned !== <span class="hljs-literal">undefined</span> || pinned) {
      dispatch({
        type: PIN,
        id,
        pinned,
        ref: ref.current
      })
    }
  }, [pinned])

  <span class="hljs-keyword">const</span> disabledRef = useRef(disabled)
  useEffect(() =&gt; {
    <span class="hljs-keyword">if</span> (useStorageReducer &amp;&amp; disabledRef.current !== disabled) {
      dispatch({
        type: DISABLE,
        id,
        disabled
      })
    }
    disabledRef.current = disabled
  }, [disabled])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tranform DOM events into reducer actions:</p>
<ul>
<li>mouseout events.</li>
<li>mouseover events.</li>
<li>mousemove events.</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> handleMouseOut = useCallback(
    event =&gt; {
      event.stopPropagation()
      <span class="hljs-keyword">if</span> (useStorageReducer) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>In storage configuration, tips have the container as a parent, not the source
Thus the first mouseover on the tip also causes a mouseout on the source
Inhibit it to avoid tip flickering</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">const</span> relatedTarget = event.relatedTarget
        <span class="hljs-keyword">if</span> (relatedTarget) {
          <span class="hljs-keyword">const</span> location = relatedTarget.closest(<span class="hljs-string">'[data-rit-id]'</span>)
          <span class="hljs-keyword">if</span> (location &amp;&amp; location.dataset.ritId === id) {
            <span class="hljs-keyword">return</span>
          }
        }
      }
      dispatch({
        type: MOUSE_OUT,
        id,
        dispatch,
        from: <span class="hljs-string">'Source'</span>,
        event: event.nativeEvent
      })
    },
    [dispatch, id]
  )

  <span class="hljs-keyword">const</span> handleMouseOver = useCallback(
    event =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This handler is required also for Storage since
the mouseOver handler at the Storage level has no
way to know the config of the source</p></div></div><div class="code"><div class="wrapper">      event.stopPropagation()
      dispatch({
        type: MOUSE_OVER,
        id,
        disabled,
        config,
        position: {
          x: event.clientX + <span class="hljs-built_in">window</span>.scrollX,
          y: event.clientY + <span class="hljs-built_in">window</span>.scrollY
        },
        dispatch,
        ref: ref.current,
        from: <span class="hljs-string">'Source'</span>,
        event: event.nativeEvent
      })
    },
    [dispatch, id, config, disabled]
  )

  <span class="hljs-keyword">const</span> handleMouseMove = useCallback(
    event =&gt; {
      event.stopPropagation()
      dispatch({
        type: MOUSE_MOVE,
        id,
        position: {
          x: event.clientX + <span class="hljs-built_in">window</span>.scrollX,
          y: event.clientY + <span class="hljs-built_in">window</span>.scrollY
        },
        from: <span class="hljs-string">'Source'</span>,
        event: event.nativeEvent
      })
    },
    [dispatch, id]
  )

  <span class="hljs-keyword">const</span> { tip, children, svg } = props</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Since a <code>Source</code> needs to handle pointer events (notably it needs to
know when the pointer enters or leaves your component so that it
can trigger the tip display), it has an actual HTML tag associated to it
(either a <code>&lt;span&gt;</code> if your component renders as HTML, or a <code>&lt;g&gt;</code> if your component renders
to SVG).
It also needs to known if the geometry of this element changes, because this
will affect tip placement, hence the <code>ref</code> which is tracked by the <code>ResizeObserver</code>.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> tagName = svg ? <span class="hljs-string">'g'</span> : <span class="hljs-string">'span'</span>
  <span class="hljs-keyword">const</span> tagProps = {
    className: <span class="hljs-string">'rit-source'</span>,
    ref,
    onMouseOut: handleMouseOut,
    onMouseOver: handleMouseOver,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is mostly transparent (the <code>&lt;span&gt;</code> uses the CSS <code>display: &#39;contents&#39;</code> property)
but there may be edge cases where one wants to be aware of this.</p></div></div><div class="code"><div class="wrapper">    ...(svg ? {} : { style: { display: <span class="hljs-string">'contents'</span> } })
  }
  <span class="hljs-keyword">const</span> tagChildren = [...React.Children.toArray(children)]
  <span class="hljs-keyword">if</span> (useStorageReducer) {
    tagProps[<span class="hljs-string">'data-rit-id'</span>] = id
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (config.position.adjust.mouse) {
      tagProps.onMouseMove = handleMouseMove
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A <code>Source</code> keeps track of four state variables</p>
<ul>
<li><code>my</code>: the position which provides optimal placement of the tip as computed by its <code>Engine</code>.</li>
<li><code>location</code>: the actual coordinates of the tip.</li>
<li><code>visible</code>: whether the tip is currently visible.</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> {
      my,
      location = {
        left: <span class="hljs-number">0</span>,
        top: <span class="hljs-number">0</span>
      },
      visible
    } = state
    <span class="hljs-keyword">if</span> (visible) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The tip itself consists of a wrapper component (<code>Balloon</code> by default)
which provides the user-supplied tip component with a tip appearance.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">const</span> { wrapper, wrapperProps } = config
      <span class="hljs-keyword">const</span> wrappedTip = React.createElement(wrapper, {
        ...wrapperProps,
        my,
        dispatch,
        children: tip
      })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A portal is used to attach the tip to another DOM parent (so that it
naturally floats above other DOM nodes it the DOM tree). The additional
benefit of the portal is that DOM events are still channeled through
the <code>Source</code>, which is required not to break timers used to show and hide tip.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">if</span> (!disabled) {
        tagChildren.push(
          ReactDOM.createPortal(
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Location</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">{id}</span> <span class="hljs-attribute">location</span>=<span class="hljs-value">{location}</span>&gt;</span>
              {wrappedTip}
            <span class="hljs-tag">&lt;/<span class="hljs-title">Location</span>&gt;</span>,
            state.containerElt
          )
        )
      }
    }
  }
  return React.createElement(tagName, tagProps, tagChildren)
}

Source.propTypes = {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The tip content as a React node</p></div></div><div class="code"><div class="wrapper">  tip: PropTypes.node,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>true</code> to make the tip always visible, <code>false</code> otherwise</p></div></div><div class="code"><div class="wrapper">  pinned: PropTypes.bool,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The tip <code>config</code>, as an object which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>position</td>
<td><code>&lt;PositionType&gt;</code></td>
<td>sub-configuration describing the tip position</td>
</tr>
<tr>
<td>show</td>
<td><code>&lt;ShowType&gt;</code></td>
<td>sub-configuration describing how the tip is shown</td>
</tr>
<tr>
<td>hide</td>
<td><code>&lt;HideType&gt;</code></td>
<td>sub-configuration describing how the tip is hidden</td>
</tr>
<tr>
<td>wrapper</td>
<td><code>&lt;component&gt;</code></td>
<td>The component to instantiate to wrap the tip</td>
</tr>
<tr>
<td>wrapperProps</td>
<td><code>&lt;object&gt;</code></td>
<td>The React properties for the wrapper component</td>
</tr>
</tbody>
</table>
<p><code>&lt;PositionType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>my</td>
<td><code>&lt;CornerType&gt;</code></td>
<td>The corner of the tip to position in relation to the <code>at</code> key</td>
</tr>
<tr>
<td>at</td>
<td><code>&lt;CornerType&gt;</code></td>
<td>The corner of <code>target</code> element to position the tip corner at</td>
</tr>
<tr>
<td>target</td>
<td><code>&lt;target-spec&gt;</code></td>
<td>The element the tip will be positioned in relation to. Can be one of <dl><dt>false</dt><dd>the source itself (default)</dd><dt>[&lt;number&gt;, &lt;number&gt;]</dt><dd>an array of x, y coordinates</dd><dt>&#39;mouse&#39;</dt><dd>the mouse coordinates for the event which triggered the tip to show</dd><dt>&lt;string&gt;</dt><dd>CSS selector for another DOMElement</dd></dl></td>
</tr>
<tr>
<td>adjust</td>
<td><code>&lt;AdjustType&gt;</code></td>
<td>sub-configuration describing how the tip position should be adjusted</td>
</tr>
<tr>
<td>container</td>
<td><code>&lt;string&gt;</code></td>
<td>CSS selector to the DOMElement under which tips will attached.</td>
</tr>
</tbody>
</table>
<p><code>&lt;CornerType&gt;</code> is one of the following enumeration value:</p>
<ul>
<li>top-left</li>
<li>top-center</li>
<li>top-right</li>
<li>center-left</li>
<li>center-right</li>
<li>bottom-left</li>
<li>bottom-center</li>
<li>bottom-right</li>
</ul>
<p><code>&lt;AdjustType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>mouse</td>
<td><code>&lt;mouse-spec&gt;</code></td>
<td>Describes how mouse movement affects the tip placement. Can be one of <dl><dt>false</dt><dd>do not adjust to mouse move (default)</dd><dt>true</dt><dd>adjust to mouse move</dd><dt><pre>function: event =&gt; ({ x, y })</pre></dt><dd>compute the position of the tip using a function which receives mouse move event as input</dd></dl></td>
</tr>
<tr>
<td>x</td>
<td><code>&lt;number&gt;</code></td>
<td>x-translation the tip (0 by default)</td>
</tr>
<tr>
<td>y</td>
<td><code>&lt;number&gt;</code></td>
<td>y-translation the tip (0 by default)</td>
</tr>
<tr>
<td>method</td>
<td><code>&lt;method-spec&gt;</code></td>
<td>Decribes the method to use to optimize tip placement inside its container. Can be one of <dl><dt>none</dt><dd>no placement adjustment (default)</dd><dt>{ flip: [&lt;CornerType&gt; (, &lt;CornerType&gt;)* ] }</dt><dd>pick the corner which maximizes overlap between the tip and its container</dd><dt>{ shift: [&lt;AxisType&gt; (, &lt;AxisType&gt;)*]}</dt><dd>keep the tip inside its container for the specified axis</dd></dl></td>
</tr>
</tbody>
</table>
<p><code>&lt;AxisType&gt;</code> is one of the following enumeration value:</p>
<ul>
<li>horizontal</li>
<li>vertical</li>
</ul>
<p><code>&lt;ShowType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>delay</td>
<td><code>&lt;number&gt;</code></td>
<td>Delay between mouse enter event in the source and the tip display (0ms by default)</td>
</tr>
</tbody>
</table>
<p><code>&lt;HideType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>delay</td>
<td><code>&lt;number&gt;</code></td>
<td>Delay between mouse leave event from the source or the tip and removal of the tip (0ms by default)</td>
</tr>
</tbody>
</table></div></div><div class="code"><div class="wrapper">  config: SourceConfig,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Must to set to <code>true</code> if the source wraps an SVG element, <code>false</code> otherwise</p></div></div><div class="code"><div class="wrapper">  svg: PropTypes.bool,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the <code>Source</code> is contained in a <code>Storage</code>, an id which uniquely identifies
this <code>Source</code> within its <code>Storage</code></p></div></div><div class="code"><div class="wrapper">  id: PropTypes.string,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>True to make the source ignore DOM events and stop showing
or hiding new tips, false (default) otherwise</p></div></div><div class="code"><div class="wrapper">  disabled: PropTypes.bool
}

Source.defaultProps = {
  pinned: <span class="hljs-literal">false</span>,
  svg: <span class="hljs-literal">false</span>,
  disabled: <span class="hljs-literal">false</span>
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> areEqual = (prev, next) =&gt; {
  <span class="hljs-keyword">return</span> (
    prev.id === next.id &amp;&amp;
    prev.config === next.config &amp;&amp;
    prev.tip === next.tip &amp;&amp;
    prev.pinned === next.pinned &amp;&amp;
    prev.disabled === next.disabled &amp;&amp;
    prev.children === next.children
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(Source, areEqual)</div></div></div></div></body></html>