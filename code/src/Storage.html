<!DOCTYPE html><html lang="en"><head><title>src/Storage</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/Storage"><meta name="groc-project-path" content="src/Storage.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Storage.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Copyright 2019 Ulrich Gaal</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<pre><code>http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<h1 id="storage">Storage</h1></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> Location <span class="hljs-keyword">from</span> <span class="hljs-string">'./Location'</span>
<span class="hljs-keyword">import</span> Engine <span class="hljs-keyword">from</span> <span class="hljs-string">'./Engine'</span>
<span class="hljs-keyword">import</span> { StorageTip } <span class="hljs-keyword">from</span> <span class="hljs-string">'./prop-types'</span>
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>
<span class="hljs-keyword">import</span> { autobind, eqSet, diffSet, getElement } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>
<span class="hljs-keyword">import</span> { ConfigContext, StorageContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Contexts'</span>
<span class="hljs-keyword">import</span> { mergeObjects } <span class="hljs-keyword">from</span> <span class="hljs-string">'.'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>Storage</code> component is in charge of persisting tips for all the
<code>Source</code>s of the React subtree of which it is the root.
A <code>Storage</code> invokes the handler specified in the <code>onTipChange</code> property
 when its list of persistent tips changes.
Using <code>Storage</code> usually implies that:</p>
<ul>
<li>a <code>Pinnable</code> wrapper component is used for the tips, so that
the user can pin them down them and drag them around.</li>
<li><code>Source</code>s do not provide their tips as usual using the <code>tip</code> config key.
Instead they provide an <code>id</code> key to uniquely identify themselves.</li>
<li>the <code>tip</code> config key of <code>Storage</code> provides all the tips
for the subtree. It must be defined as a function which receives as
input a <code>Source</code> <code>id</code> and outputs the corresponding tip.</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Storage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  constructor (props) {
    <span class="hljs-keyword">super</span>(props)
    autobind([<span class="hljs-string">'handleToggle'</span>, <span class="hljs-string">'handleMouseDown'</span>], <span class="hljs-keyword">this</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>engines</code> is a hash of <code>Source</code> <code>id</code> to <code>Engine</code> references.
An <code>Engine</code> reference has the form { refCount: <number>, value: <Engine> }.
A <code>Source</code> in the React subtree or a pinned tip increase the refCount
of the <code>Engine</code> reference. If it reaches 0, the reference is purged.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.engines = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A <code>Storage</code> keeps track of one state variable:
a hash of <code>Source</code> <code>id</code> to tip state. Each tip state consists in four fields:</p>
<ul>
<li><code>pinned</code>: true if the tip is currently pinned</li>
<li><code>my</code>: the position which provides optimal placement of the tip as computed by its <code>Engine</code>.</li>
<li><code>location</code>: the actual coordinates of the tip.</li>
<li><code>visible</code>: whether the tip is currently visible.</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.state = {
      tips: {}
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create a new <code>Engine</code> which will be shared by <code>Storage</code> and <code>Source</code></p></div></div><div class="code"><div class="wrapper">  getEngine ({ id, config }) {
    <span class="hljs-keyword">const</span> ref = <span class="hljs-keyword">this</span>.engines[id]
    <span class="hljs-keyword">if</span> (ref) {
      ref.refCount++
      <span class="hljs-keyword">return</span> ref.value
    }
    <span class="hljs-keyword">const</span> engine = <span class="hljs-keyword">new</span> Engine({
      id,
      config,
      output: <span class="hljs-keyword">this</span>
    })
    <span class="hljs-keyword">this</span>.engines[id] = {
      refCount: <span class="hljs-number">1</span>,
      value: engine
    }
    <span class="hljs-keyword">return</span> engine
  }

  release (id) {
    <span class="hljs-keyword">const</span> ref = <span class="hljs-keyword">this</span>.engines[id]
    <span class="hljs-keyword">if</span> (!ref) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Invalid release <span class="hljs-subst">${id}</span>`</span>)
    }
    ref.refCount--
    <span class="hljs-keyword">if</span> (ref.refCount === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.engines[id]
    }
  }

  deref (id) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.engines[id].value
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>updateEngines</code> is invoked when the <code>tips</code> state variable
changes (for instance when a persistent tip needs to be
displayed but its <code>Source</code> is not attached to the subtree yet).</p></div></div><div class="code"><div class="wrapper">  updateEngines (tips, prevTips) {
    <span class="hljs-keyword">const</span> ids = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(tips.map(({ id }) =&gt; id))
    <span class="hljs-keyword">const</span> prevIds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(prevTips.map(({ id }) =&gt; id))
    <span class="hljs-keyword">if</span> (!eqSet(ids, prevIds)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create engines for new ids</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> diffSet(ids, prevIds)) {
        <span class="hljs-keyword">const</span> tip = tips.find(tip =&gt; tip.id === id)
        <span class="hljs-keyword">const</span> config = mergeObjects(<span class="hljs-keyword">this</span>.context, tip.config)
        <span class="hljs-keyword">this</span>.getEngine({ id, config })
      }
    }
  }

  componentDidMount () {
    <span class="hljs-keyword">const</span> { tips } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">this</span>.updateEngines(<span class="hljs-keyword">this</span>.props.tips, [])
    <span class="hljs-keyword">this</span>.setState({
      tips: (tips || []).reduce((tips, { id, my, location }) =&gt; {
        tips[id] = {
          visible: <span class="hljs-literal">true</span>,
          pinned: <span class="hljs-literal">true</span>,
          my,
          location
        }
        <span class="hljs-keyword">this</span>.deref(id).pinned = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">return</span> tips
      }, {})
    })
  }

  componentDidUpdate (prevProps) {
    <span class="hljs-keyword">this</span>.updateEngines(<span class="hljs-keyword">this</span>.props.tips, prevProps.tips)
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This method is invoked by <code>Engine</code> when the tip location changes.</p></div></div><div class="code"><div class="wrapper">  onLayoutChange ({ id, my, location, config }) {
    <span class="hljs-keyword">const</span> { pinned } = <span class="hljs-keyword">this</span>.getTip(id)
    <span class="hljs-keyword">if</span> (!pinned) {
      <span class="hljs-keyword">this</span>.updateTip(id, { my, location, config })
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This method is invoked by <code>Engine</code> when the tip visibility changes.</p></div></div><div class="code"><div class="wrapper">  onVisibilityChange ({ id, visible, config }) {
    <span class="hljs-keyword">const</span> tips = { ...this.state.tips }
    <span class="hljs-keyword">if</span> (visible) {
      tips[id] = {
        my: <span class="hljs-string">'top-left'</span>,
        location: {
          left: <span class="hljs-number">0</span>,
          top: <span class="hljs-number">0</span>
        },
        visible,
        config
      }
      <span class="hljs-keyword">this</span>.getEngine({ id, config })
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">delete</span> tips[id]
      <span class="hljs-keyword">this</span>.release(id)
    }
    <span class="hljs-keyword">this</span>.setState({ tips })
  }

  getTip (id) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.tips[id]
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is method updates the state fields (<code>pinned</code>, <code>my</code>, <code>location</code> or <code>visible</code>)
of a tip identified by its <code>id</code>.</p></div></div><div class="code"><div class="wrapper">  updateTip (id, state) {
    <span class="hljs-keyword">const</span> tips = <span class="hljs-keyword">this</span>.state.tips
    <span class="hljs-keyword">const</span> nextTips = {
      ...tips,
      [id]: {
        ...tips[id],
        ...state
      }
    }
    <span class="hljs-keyword">this</span>.setState({
      tips: nextTips
    })
    <span class="hljs-keyword">return</span> nextTips
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This method invokes the handler specified in the <code>onTipChange</code> property
when the list of persistent tips changes.</p></div></div><div class="code"><div class="wrapper">  dispatchTipChange (tips) {
    <span class="hljs-keyword">const</span> { onTipChange } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onTipChange === <span class="hljs-string">'function'</span>) {
      onTipChange(
        <span class="hljs-built_in">Object</span>.entries(tips)
          .filter(([, { pinned }]) =&gt; pinned)
          .map(([id, { my, location, config }]) =&gt; ({
            id,
            my,
            location,
            config
          }))
      )
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>handleToggle</code> and <code>handleMouseDown</code> methods are invoked when
the push pin of the <code>Pinnable</code> wrapper is clicked or the <code>Pinnable</code>
is dragged</p></div></div><div class="code"><div class="wrapper">  handleToggle (id, event) {
    event.preventDefault()
    event.stopPropagation()
    <span class="hljs-keyword">const</span> tip = <span class="hljs-keyword">this</span>.getTip(id)
    <span class="hljs-keyword">this</span>.deref(id).pin(!tip.pinned)
    <span class="hljs-keyword">this</span>.dispatchTipChange(<span class="hljs-keyword">this</span>.updateTip(id, { pinned: !tip.pinned }))
  }

  handleMouseDown (id, event) {
    <span class="hljs-keyword">const</span> p0 = { x: event.clientX, y: event.clientY }
    event.stopPropagation()
    event.preventDefault()
    <span class="hljs-keyword">const</span> handlers = {}
    <span class="hljs-keyword">const</span> updatePosition = event =&gt; {
      event.stopPropagation()
      event.preventDefault()
      <span class="hljs-keyword">const</span> {
        location: { left, top }
      } = <span class="hljs-keyword">this</span>.getTip(id)
      <span class="hljs-keyword">const</span> tips = <span class="hljs-keyword">this</span>.updateTip(id, {
        location: {
          left: left + event.clientX - p0.x,
          top: top + event.clientY - p0.y
        }
      })
      p0.x = event.clientX
      p0.y = event.clientY
      <span class="hljs-keyword">return</span> tips
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Position mouse handlers to create a modal drag loop</p></div></div><div class="code"><div class="wrapper">    handlers.handleMouseMove = updatePosition
    handlers.handleMouseUp = event =&gt; {
      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'mousemove'</span>, handlers.handleMouseMove, <span class="hljs-literal">true</span>)
      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'mouseup'</span>, handlers.handleMouseUp, <span class="hljs-literal">true</span>)
      updatePosition(event)
      <span class="hljs-keyword">this</span>.dispatchTipChange(updatePosition(event))
    }
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, handlers.handleMouseMove, <span class="hljs-literal">true</span>)
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mouseup'</span>, handlers.handleMouseUp, <span class="hljs-literal">true</span>)
  }

  render () {
    <span class="hljs-keyword">const</span> { children, tip } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">const</span> { tips } = <span class="hljs-keyword">this</span>.state
    <span class="hljs-keyword">return</span> (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Configure <code>Source</code>s in the React subtree so that
they have a <code>storage</code> property pointing to the <code>Storage</code>.</p></div></div><div class="code"><div class="wrapper">      &lt;div style={{ display: <span class="hljs-string">'contents'</span> }}&gt;
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">StorageContext.Provider</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">{this}</span>&gt;</span>
          {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Render the React subtree</p></div></div><div class="code"><div class="wrapper">            children
          }
        &lt;<span class="hljs-regexp">/StorageContext.Provider&gt;
        {Object.entries(tips)
          .filter(([, { visible }]) =&gt; visible)
          .map(([id, value]) =&gt; {
            const { my, location, pinned, config: sourceConfig } = value
            const config = mergeObjects(this.context, sourceConfig)
            const { wrapper, wrapperProps, position } = config
            const container = getElement(position.container)
</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve the tip for the specified id.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">const</span> tipContent = tip(id, pinned)
            <span class="hljs-keyword">if</span> (tipContent) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve the <code>Engine</code> for the specified id.
<code>Engine</code> will handle mouseover and mouseout events as well as
changes to the tip geometry, whereas <code>Storage</code> will handle
mousedown and push pin click events</p></div></div><div class="code"><div class="wrapper">              <span class="hljs-keyword">const</span> engine = <span class="hljs-keyword">this</span>.deref(id)
              <span class="hljs-keyword">const</span> tip = React.createElement(wrapper, {
                ...wrapperProps,
                my,
                pinned,
                onGeometryChange: geometry =&gt; engine.update({ geometry }),
                onToggle: event =&gt; <span class="hljs-keyword">this</span>.handleToggle(id, event),
                onMouseDown: event =&gt; <span class="hljs-keyword">this</span>.handleMouseDown(id, event),
                children: [tipContent]
              })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A portal is used to attach the tip to another DOM parent (so that it
naturally floats above other DOM nodes it the DOM tree). The additional
benefit of the portal is that DOM events are still channeled through
the <code>Engine</code>, which is required not to break timers used to show and hide tip.</p></div></div><div class="code"><div class="wrapper">              <span class="hljs-keyword">return</span> ReactDOM.createPortal(
                <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Location</span>
                  <span class="hljs-attribute">key</span>=<span class="hljs-value">{id}</span>
                  <span class="hljs-attribute">location</span>=<span class="hljs-value">{location}</span>
                  <span class="hljs-attribute">onMouseOver</span>=<span class="hljs-value">{event</span> =&gt;</span> engine.handleMouseOver(event)}
                  onMouseOut={event =&gt; engine.handleMouseOut(event)}
                &gt;
                  {tip}
                <span class="hljs-tag">&lt;/<span class="hljs-title">Location</span>&gt;</span>,
                container
              )
            }
            return null
          })}
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>
  }
}
Storage.contextType = ConfigContext

Storage.propTypes = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The list of persisted tips. Each entry of the list is an object with
the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td><code>&lt;string&gt;</code></td>
<td>The id property of the <code>&lt;Source&gt;</code> to which the tip belongs</td>
</tr>
<tr>
<td>my</td>
<td><code>&lt;CornerType&gt;</code></td>
<td>The corner of the tip to which the tail attaches</td>
</tr>
<tr>
<td>location</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The current tip location</td>
</tr>
<tr>
<td>config</td>
<td><code>&lt;ConfigType&gt;</code></td>
<td>The tip config (see Source for details on <code>&lt;ConfigType&gt;</code>)</td>
</tr>
</tbody>
</table>
<p><code>&lt;LocationType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td><code>&lt;number&gt;</code></td>
<td>The x coordinate of the tip in the tip-container coordinate system.</td>
</tr>
<tr>
<td>top</td>
<td><code>&lt;number&gt;</code></td>
<td>The y coordinate of the tip in the tip-container coordinate system.</td>
</tr>
</tbody>
</table></div></div><div class="code"><div class="wrapper">  tips: PropTypes.arrayOf(StorageTip),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A function which receives as input a <code>Source</code> <code>id</code> and outputs the corresponding React tip
element.</p></div></div><div class="code"><div class="wrapper">  tip: PropTypes.func,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A callback function invoked when the list of persistent tip changes.
The function receives an array of</p></div></div><div class="code"><div class="wrapper">  onTipChange: PropTypes.func
}</div></div></div></div></body></html>