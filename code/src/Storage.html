<!DOCTYPE html><html lang="en"><head><title>src/Storage</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/Storage"><meta name="groc-project-path" content="src/Storage.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Storage.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Copyright 2019 Ulrich Gaal</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<pre><code>http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<h1 id="storage">Storage</h1></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> React, { useReducer, useCallback, useRef, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> Location <span class="hljs-keyword">from</span> <span class="hljs-string">'./Location'</span>
<span class="hljs-keyword">import</span> { StorageTip } <span class="hljs-keyword">from</span> <span class="hljs-string">'./prop-types'</span>
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>
<span class="hljs-keyword">import</span> { StorageContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Contexts'</span>
<span class="hljs-keyword">import</span> { LOGS } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>
<span class="hljs-keyword">import</span> {
  storageInit,
  storageReducer,
  UPDATE_PINNED,
  MOVE
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers/storageReducer'</span>
<span class="hljs-keyword">import</span> { MOUSE_OVER, MOUSE_OUT, PIN } <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers/sourceReducer'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>Storage</code> component is in charge of persisting tips for all the
<code>Source</code>s of the React subtree of which it is the root.
A <code>Storage</code> invokes the handler specified in the <code>onTipChange</code> property
 when its list of persistent tips changes.
Using <code>Storage</code> usually implies that:</p>
<ul>
<li>a <code>Pinnable</code> wrapper component is used for the tips, so that
the user can pin them down them and drag them around.</li>
<li><code>Source</code>s do not provide their tips as usual using the <code>tip</code> config key.
Instead they provide an <code>id</code> key to uniquely identify themselves.</li>
<li>the <code>tip</code> config key of <code>Storage</code> provides all the tips
for the subtree. It must be defined as a function which receives as
input a <code>Source</code> <code>id</code> and outputs the corresponding tip.</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> Storage = props =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>console.log(&#39;Storage&#39;, props)</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> { children, tip, tips: storedTips, onTipChange } = props</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A <code>Storage</code> keeps track of one state variable:
a hash of <code>Source</code> <code>id</code> to refcounted source state.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> [state, dispatch] = useReducer(
    storageReducer,
    { storedTips, onTipChange },
    storageInit
  )
  <span class="hljs-keyword">if</span> (LOGS.storage &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Storage'</span>, props, state)
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Notify the reducer if the list of persisted tips
changes</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> prevStoredTipsRef = useRef()
  useEffect(() =&gt; {
    prevStoredTipsRef.current = storedTips
  })
  <span class="hljs-keyword">const</span> prevStoredTips = prevStoredTipsRef.current
  useEffect(() =&gt; {
    dispatch({ type: UPDATE_PINNED, storedTips, prevStoredTips })
  }, [storedTips])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This callback is passed to sources so that they
get access to the dispatch of the storageReducer</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> storage = useCallback(params =&gt; {
    <span class="hljs-keyword">return</span> [params, dispatch]
  }, [])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Tranform DOM events into reducer actions (events
actually come from sources and bubble to the storage):</p>
<ul>
<li>click events.</li>
<li>mousedown events.</li>
<li>mouseout events.</li>
<li>mouseover events.</li>
<li>mousemove events.</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> handlePin = useCallback(event =&gt; {
    <span class="hljs-keyword">const</span> target = event.target.closest(<span class="hljs-string">'[data-rit-id]'</span>)
    <span class="hljs-keyword">if</span> (target) {
      <span class="hljs-keyword">const</span> id = target.dataset.ritId
      event.stopPropagation()
      event.preventDefault()
      dispatch({ type: PIN, id, ref: target })
    }
  }, [])

  <span class="hljs-keyword">const</span> handleMouseDown = useCallback(
    event =&gt; {
      <span class="hljs-keyword">const</span> target = event.target.closest(<span class="hljs-string">'[data-rit-id]'</span>)
      <span class="hljs-keyword">if</span> (target) {
        <span class="hljs-keyword">const</span> id = target.dataset.ritId
        <span class="hljs-keyword">const</span> p0 = { x: event.clientX, y: event.clientY }
        event.stopPropagation()
        event.preventDefault()
        <span class="hljs-keyword">const</span> handlers = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Position mouse handlers to create a modal drag loop</p></div></div><div class="code"><div class="wrapper">        handlers.handleMouseMove = event =&gt; {
          event.preventDefault()
          event.stopPropagation()
          dispatch({
            type: MOVE,
            id,
            delta: { x: event.clientX - p0.x, y: event.clientY - p0.y }
          })
          p0.x = event.clientX
          p0.y = event.clientY
        }
        handlers.handleMouseUp = event =&gt; {
          event.preventDefault()
          event.stopPropagation()
          <span class="hljs-built_in">window</span>.removeEventListener(
            <span class="hljs-string">'mousemove'</span>,
            handlers.handleMouseMove,
            <span class="hljs-literal">true</span>
          )
          <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'mouseup'</span>, handlers.handleMouseUp, <span class="hljs-literal">true</span>)
          dispatch({
            type: MOVE,
            id,
            delta: { x: event.clientX - p0.x, y: event.clientY - p0.y },
            notify: <span class="hljs-literal">true</span>
          })
        }
        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, handlers.handleMouseMove, <span class="hljs-literal">true</span>)
        <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mouseup'</span>, handlers.handleMouseUp, <span class="hljs-literal">true</span>)
      }
    },
    [dispatch]
  )

  <span class="hljs-keyword">const</span> handleMouseOut = useCallback(
    event =&gt; {
      <span class="hljs-keyword">const</span> target = event.target.closest(<span class="hljs-string">'[data-rit-id]'</span>)
      <span class="hljs-keyword">if</span> (target) {
        <span class="hljs-keyword">const</span> id = target.dataset.ritId
        dispatch({ type: MOUSE_OUT, id, dispatch })
      }
    },
    [dispatch]
  )

  <span class="hljs-keyword">const</span> handleMouseOver = useCallback(
    event =&gt; {
      <span class="hljs-keyword">const</span> target = event.target.closest(<span class="hljs-string">'[data-rit-id]'</span>)
      <span class="hljs-keyword">if</span> (target) {
        <span class="hljs-keyword">const</span> id = target.dataset.ritId
        dispatch({
          type: MOUSE_OVER,
          id,
          position: { x: event.clientX, y: event.clientY },
          dispatch,
          ref: target
        })
      }
    },
    [dispatch]
  )

  <span class="hljs-keyword">return</span> (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Configure <code>Source</code>s in the React subtree so that
they have a <code>storage</code> property pointing to the <code>Storage</code>.</p></div></div><div class="code"><div class="wrapper">    &lt;div
      style={{ display: <span class="hljs-string">'contents'</span> }}
      onMouseOut={handleMouseOut}
      onMouseOver={handleMouseOver}
    &gt;
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">StorageContext.Provider</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">{storage}</span>&gt;</span>
        {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Render the React subtree (which contains the <code>Source</code>s)</p></div></div><div class="code"><div class="wrapper">          children
        }
      &lt;<span class="hljs-regexp">/StorageContext.Provider&gt;
      {Object.values(state.sources)
        .filter(({ source: { visible } }) =&gt; visible)
        .map(({ source }) =&gt; {
          const {
            id,
            my,
            location = {
              left: 0,
              top: 0
            },
            pinned,
            config,
            containerElt
          } = source
          const { wrapper, wrapperProps } = config
</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve the tip for the specified id.</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">const</span> tipContent = tip(id, pinned)
          <span class="hljs-keyword">if</span> (tipContent) {
            <span class="hljs-keyword">const</span> tip = React.createElement(wrapper, {
              ...wrapperProps,
              my,
              pinned,
              id,
              dispatch,
              onPin: handlePin,
              onMouseDown: handleMouseDown,
              children: [tipContent]
            })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A portal is used to attach the tip to another DOM parent (so that it
naturally floats above other DOM nodes it the DOM tree). The additional
benefit of the portal is that DOM events are still channeled through
the reducer, which is required not to break timers used to show and hide tip.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">return</span> ReactDOM.createPortal(
              <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Location</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{id}</span> <span class="hljs-attribute">location</span>=<span class="hljs-value">{location}</span>&gt;</span>
                {tip}
              <span class="hljs-tag">&lt;/<span class="hljs-title">Location</span>&gt;</span>,
              containerElt
            )
          }
          return null
        })}
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  )</span>
}

Storage.propTypes = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The list of persisted tips. Each entry of the list is an object with
the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td><code>&lt;string&gt;</code></td>
<td>The id property of the <code>&lt;Source&gt;</code> to which the tip belongs</td>
</tr>
<tr>
<td>my</td>
<td><code>&lt;CornerType&gt;</code></td>
<td>The corner of the tip to which the tail attaches</td>
</tr>
<tr>
<td>location</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The current tip location</td>
</tr>
<tr>
<td>config</td>
<td><code>&lt;ConfigType&gt;</code></td>
<td>The tip config (see Source for details on <code>&lt;ConfigType&gt;</code>)</td>
</tr>
</tbody>
</table>
<p><code>&lt;LocationType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td><code>&lt;number&gt;</code></td>
<td>The x coordinate of the tip in the tip-container coordinate system.</td>
</tr>
<tr>
<td>top</td>
<td><code>&lt;number&gt;</code></td>
<td>The y coordinate of the tip in the tip-container coordinate system.</td>
</tr>
</tbody>
</table></div></div><div class="code"><div class="wrapper">  tips: PropTypes.arrayOf(StorageTip),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A function which receives as input a <code>Source</code> <code>id</code> and outputs the corresponding React tip
element.</p></div></div><div class="code"><div class="wrapper">  tip: PropTypes.func,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A callback function invoked when the list of persistent tip changes.
The function receives an array of</p></div></div><div class="code"><div class="wrapper">  onTipChange: PropTypes.func
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Storage</div></div></div></div></body></html>