<!DOCTYPE html><html lang="en"><head><title>src/Storage</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/Storage"><meta name="groc-project-path" content="src/Storage.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Storage.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Copyright 2019 Ulrich Gaal</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<pre><code>http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<h1 id="storage">Storage</h1></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>
<span class="hljs-keyword">import</span> Location <span class="hljs-keyword">from</span> <span class="hljs-string">'./Location'</span>
<span class="hljs-keyword">import</span> Engine <span class="hljs-keyword">from</span> <span class="hljs-string">'./Engine'</span>
<span class="hljs-keyword">import</span> { StorageTip, SourceConfig } <span class="hljs-keyword">from</span> <span class="hljs-string">'./prop-types'</span>
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>
<span class="hljs-keyword">import</span> { autobind, eqSet, diffSet, getElement } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>
<span class="hljs-keyword">import</span> { ConfigContext, StorageContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Contexts'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>Storage</code> component is in charge of persisting tips for all the
<code>Source</code>s of the React subtree of which it is the root.
A <code>Storage</code> invokes the handler specified in the <code>onTipChange</code> property
 when its list of persistent tips changes.
Using <code>Storage</code> usually implies that:</p>
<ul>
<li>a <code>Pinnable</code> wrapper component is used for the tips, so that
the user can pin them down them and drag them around.</li>
<li><code>Source</code>s do not provide their tips as usual using the <code>tip</code> config key.
Instead they provide an <code>id</code> key to uniquely identify themselves.</li>
<li>the <code>tip</code> config key of <code>Storage</code> provides all the tips
for the subtree. It must be defined as a function which receives as
input a <code>Source</code> <code>id</code> and outputs the corresponding tip.</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Storage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  constructor (props) {
    <span class="hljs-keyword">super</span>(props)
    autobind([<span class="hljs-string">'handleToggle'</span>, <span class="hljs-string">'handleMouseDown'</span>], <span class="hljs-keyword">this</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>engines</code> is a hash of <code>Source</code> <code>id</code> to <code>Engine</code> for all the <code>Source</code>
in the React subtree</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.engines = {}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A <code>Storage</code> keeps track of one state variable:
a hash of <code>Source</code> <code>id</code> to tip state. Each tip state consists in four fields:</p>
<ul>
<li><code>pinned</code>: true if the tip is currently pinned</li>
<li><code>my</code>: the position which provides optimal placement of the tip as computed by its <code>Engine</code>.</li>
<li><code>location</code>: the actual coordinates of the tip.</li>
<li><code>visible</code>: whether the tip is currently visible.</li>
</ul></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">this</span>.state = {
      tips: {}
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>register</code> and <code>unregister</code> are invoked by the <code>Source</code>s
in the subtree. These methods ensure that the <code>Source</code> and
the <code>Storage</code> use the same engine</p></div></div><div class="code"><div class="wrapper">  register (id, source) {
    <span class="hljs-keyword">const</span> { config } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">let</span> engine = <span class="hljs-keyword">this</span>.engines[id]
    <span class="hljs-keyword">if</span> (!engine) {
      engine = <span class="hljs-keyword">this</span>.engines[id] = <span class="hljs-keyword">new</span> Engine({ id, config })
    }
    engine.subscribe(source)
    engine.subscribe(<span class="hljs-keyword">this</span>)
    <span class="hljs-keyword">return</span> engine
  }

  unregister (id, source) {
    <span class="hljs-keyword">const</span> { tips } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">const</span> engine = <span class="hljs-keyword">this</span>.engines[id]
    <span class="hljs-keyword">if</span> (engine) {
      engine.unsubscribe(source)
      <span class="hljs-keyword">if</span> (tips.findIndex(tip =&gt; tip.id === id) === -<span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Source with no persistent tip unmounts</p></div></div><div class="code"><div class="wrapper">        engine.unsubscribe(<span class="hljs-keyword">this</span>)
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.engines[id]
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>updateEngines</code> is invoked when the <code>tips</code> state variable
changes (for instance when a persistent tip needs to be
displayed but its <code>Source</code> is not attached to the subtree yet).</p></div></div><div class="code"><div class="wrapper">  updateEngines (tips, prevTips) {
    <span class="hljs-keyword">const</span> ids = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(tips.map(({ id }) =&gt; id))
    <span class="hljs-keyword">const</span> prevIds = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(prevTips.map(({ id }) =&gt; id))
    <span class="hljs-keyword">if</span> (!eqSet(ids, prevIds)) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Create engines for new ids</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-keyword">const</span> { config } = <span class="hljs-keyword">this</span>.props
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> diffSet(ids, prevIds)) {
        <span class="hljs-keyword">let</span> engine = <span class="hljs-keyword">this</span>.engines[id]
        <span class="hljs-keyword">if</span> (!engine) {
          engine = <span class="hljs-keyword">this</span>.engines[id] = <span class="hljs-keyword">new</span> Engine({ id, config })
        }
        engine.subscribe(<span class="hljs-keyword">this</span>)
      }
    }
  }

  componentDidMount () {
    <span class="hljs-keyword">const</span> { tips, config } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">this</span>.updateEngines(<span class="hljs-keyword">this</span>.props.tips, [])
    <span class="hljs-keyword">this</span>.setState({
      tips: (tips || []).reduce((tips, { id, my, location }) =&gt; {
        tips[id] = {
          visible: <span class="hljs-literal">true</span>,
          pinned: <span class="hljs-literal">true</span>,
          my,
          location
        }
        <span class="hljs-keyword">this</span>.engines[id].pinned = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">return</span> tips
      }, {})
    })
    <span class="hljs-keyword">this</span>.container = getElement(config.position.container)
  }

  componentDidUpdate (prevProps) {
    <span class="hljs-keyword">this</span>.updateEngines(<span class="hljs-keyword">this</span>.props.tips, prevProps.tips)
  }

  componentWillUnmount () {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Stop receiving onLayoutChange and onVisibilityChange events.</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-built_in">Object</span>.values(<span class="hljs-keyword">this</span>.engines).forEach(engine =&gt; {
      engine.unsubscribe(<span class="hljs-keyword">this</span>)
    })
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This method is invoked by <code>Engine</code> when the tip location changes.</p></div></div><div class="code"><div class="wrapper">  onLayoutChange ({ id, my, location }) {
    <span class="hljs-keyword">const</span> { pinned } = <span class="hljs-keyword">this</span>.getTip(id)
    <span class="hljs-keyword">if</span> (!pinned) {
      <span class="hljs-keyword">this</span>.updateTip(id, { my, location })
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This method is invoked by <code>Engine</code> when the tip visibility changes.</p></div></div><div class="code"><div class="wrapper">  onVisibilityChange ({ id, visible }) {
    <span class="hljs-keyword">const</span> tips = { ...this.state.tips }
    <span class="hljs-keyword">if</span> (visible) {
      tips[id] = {
        my: <span class="hljs-string">'top-left'</span>,
        location: {
          left: <span class="hljs-number">0</span>,
          top: <span class="hljs-number">0</span>
        },
        visible
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">delete</span> tips[id]
      <span class="hljs-keyword">const</span> engine = <span class="hljs-keyword">this</span>.engines[id]
      <span class="hljs-keyword">if</span> (engine.subscribers.size === <span class="hljs-number">1</span>) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Persistent tip closes, no associated source</p></div></div><div class="code"><div class="wrapper">        engine.unsubscribe(<span class="hljs-keyword">this</span>)
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.engines[id]
      }
    }
    <span class="hljs-keyword">this</span>.setState({ tips })
  }

  getTip (id) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.tips[id]
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This is method updates the state fields (<code>pinned</code>, <code>my</code>, <code>location</code> or <code>visible</code>)
of a tip identified by its <code>id</code>.</p></div></div><div class="code"><div class="wrapper">  updateTip (id, state) {
    <span class="hljs-keyword">const</span> tips = <span class="hljs-keyword">this</span>.state.tips
    <span class="hljs-keyword">const</span> nextTips = {
      ...tips,
      [id]: {
        ...tips[id],
        ...state
      }
    }
    <span class="hljs-keyword">this</span>.setState({
      tips: nextTips
    })
    <span class="hljs-keyword">return</span> nextTips
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This method invokes the handler specified in the <code>onTipChange</code> property
when the list of persistent tips changes.</p></div></div><div class="code"><div class="wrapper">  dispatchTipChange (tips) {
    <span class="hljs-keyword">const</span> { onTipChange } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onTipChange === <span class="hljs-string">'function'</span>) {
      onTipChange(
        <span class="hljs-built_in">Object</span>.entries(tips)
          .filter(([, { pinned }]) =&gt; pinned)
          .map(([id, { my, location }]) =&gt; ({ id, my, location }))
      )
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>handleToggle</code> and <code>handleMouseDown</code> methods are invoked when
the push pin of the <code>Pinnable</code> wrapper is clicked or the <code>Pinnable</code>
is dragged</p></div></div><div class="code"><div class="wrapper">  handleToggle (id, event) {
    event.preventDefault()
    event.stopPropagation()
    <span class="hljs-keyword">const</span> tip = <span class="hljs-keyword">this</span>.getTip(id)
    <span class="hljs-keyword">this</span>.engines[id].pin(!tip.pinned)
    <span class="hljs-keyword">this</span>.dispatchTipChange(<span class="hljs-keyword">this</span>.updateTip(id, { pinned: !tip.pinned }))
  }

  handleMouseDown (id, event) {
    <span class="hljs-keyword">const</span> p0 = { x: event.clientX, y: event.clientY }
    event.stopPropagation()
    event.preventDefault()
    <span class="hljs-keyword">const</span> handlers = {}
    <span class="hljs-keyword">const</span> updatePosition = event =&gt; {
      event.stopPropagation()
      event.preventDefault()
      <span class="hljs-keyword">const</span> {
        location: { left, top }
      } = <span class="hljs-keyword">this</span>.getTip(id)
      <span class="hljs-keyword">const</span> tips = <span class="hljs-keyword">this</span>.updateTip(id, {
        location: {
          left: left + event.clientX - p0.x,
          top: top + event.clientY - p0.y
        }
      })
      p0.x = event.clientX
      p0.y = event.clientY
      <span class="hljs-keyword">return</span> tips
    }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Position mouse handlers to create a modal drag loop</p></div></div><div class="code"><div class="wrapper">    handlers.handleMouseMove = updatePosition
    handlers.handleMouseUp = event =&gt; {
      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'mousemove'</span>, handlers.handleMouseMove, <span class="hljs-literal">true</span>)
      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'mouseup'</span>, handlers.handleMouseUp, <span class="hljs-literal">true</span>)
      updatePosition(event)
      <span class="hljs-keyword">this</span>.dispatchTipChange(updatePosition(event))
    }
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, handlers.handleMouseMove, <span class="hljs-literal">true</span>)
    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mouseup'</span>, handlers.handleMouseUp, <span class="hljs-literal">true</span>)
  }

  render () {
    <span class="hljs-keyword">const</span> {
      children,
      tip,
      config: { wrapper, wrapperProps }
    } = <span class="hljs-keyword">this</span>.props
    <span class="hljs-keyword">const</span> { tips } = <span class="hljs-keyword">this</span>.state
    <span class="hljs-keyword">return</span> (</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Configure <code>Source</code>s in the React subtree so that
they have a <code>storage</code> property pointing to the <code>Storage</code>.</p></div></div><div class="code"><div class="wrapper">      &lt;div style={{ display: <span class="hljs-string">'contents'</span> }}&gt;
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">StorageContext.Provider</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">{this}</span>&gt;</span>
          {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Render the React subtree</p></div></div><div class="code"><div class="wrapper">            children
          }
        &lt;<span class="hljs-regexp">/StorageContext.Provider&gt;
        {Object.entries(tips)
          .filter(([, { visible }]) =&gt; visible)
          .map(([id, { my, location, pinned }]) =&gt; {</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve the tip for the specified id.</p></div></div><div class="code"><div class="wrapper">            <span class="hljs-keyword">const</span> tipContent = tip(id, pinned)
            <span class="hljs-keyword">if</span> (tipContent) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve the <code>Engine</code> for the specified id.
<code>Engine</code> will handle mouseover and mouseout events as well as
changes to the tip geometry, whereas <code>Storage</code> will handle
mousedown and push pin click events</p></div></div><div class="code"><div class="wrapper">              <span class="hljs-keyword">const</span> engine = <span class="hljs-keyword">this</span>.engines[id]
              <span class="hljs-keyword">const</span> tip = React.createElement(wrapper, {
                ...wrapperProps,
                my,
                pinned,
                onGeometryChange: geometry =&gt; engine.update({ geometry }),
                onToggle: event =&gt; <span class="hljs-keyword">this</span>.handleToggle(id, event),
                onMouseDown: event =&gt; <span class="hljs-keyword">this</span>.handleMouseDown(id, event),
                children: [tipContent]
              })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A portal is used to attach the tip to another DOM parent (so that it
naturally floats above other DOM nodes it the DOM tree). The additional
benefit of the portal is that DOM events are still channeled through
the <code>Engine</code>, which is required not to break timers used to show and hide tip.</p></div></div><div class="code"><div class="wrapper">              <span class="hljs-keyword">return</span> ReactDOM.createPortal(
                <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Location</span>
                  <span class="hljs-attribute">key</span>=<span class="hljs-value">{id}</span>
                  <span class="hljs-attribute">location</span>=<span class="hljs-value">{location}</span>
                  <span class="hljs-attribute">onMouseOver</span>=<span class="hljs-value">{event</span> =&gt;</span> engine.handleMouseOver(event)}
                  onMouseOut={event =&gt; engine.handleMouseOut(event)}
                &gt;
                  {tip}
                <span class="hljs-tag">&lt;/<span class="hljs-title">Location</span>&gt;</span>,
                this.container
              )
            }
            return null
          })}
      <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    )</span>
  }
}

Storage.propTypes = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The list of persisted tips. Each entry of the list is an object with
the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td><code>&lt;string&gt;</code></td>
<td>The id property of the <code>&lt;Source&gt;</code> to which the tip belongs</td>
</tr>
<tr>
<td>my</td>
<td><code>&lt;CornerType&gt;</code></td>
<td>The corner of the tip to which the tail attaches</td>
</tr>
<tr>
<td>location</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The current tip location</td>
</tr>
</tbody>
</table>
<p><code>&lt;LocationType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td><code>&lt;number&gt;</code></td>
<td>The x coordinate of the tip in the tip-container coordinate system.</td>
</tr>
<tr>
<td>top</td>
<td><code>&lt;number&gt;</code></td>
<td>The y coordinate of the tip in the tip-container coordinate system.</td>
</tr>
</tbody>
</table></div></div><div class="code"><div class="wrapper">  tips: PropTypes.arrayOf(StorageTip),</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A function which receives as input a <code>Source</code> <code>id</code> and outputs the corresponding React tip
element.</p></div></div><div class="code"><div class="wrapper">  tip: PropTypes.func,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A callback function invoked when the list of persistent tip changes</p></div></div><div class="code"><div class="wrapper">  onTipChange: PropTypes.func,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The tip <code>config</code>, as an object which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>position</td>
<td><code>&lt;PositionType&gt;</code></td>
<td>sub-configuration describing the tip position</td>
</tr>
<tr>
<td>show</td>
<td><code>&lt;ShowType&gt;</code></td>
<td>sub-configuration describing how the tip is shown</td>
</tr>
<tr>
<td>hide</td>
<td><code>&lt;HideType&gt;</code></td>
<td>sub-configuration describing how the tip is hidden</td>
</tr>
<tr>
<td>wrapper</td>
<td><code>&lt;component&gt;</code></td>
<td>The component to instantiate to wrap the tip</td>
</tr>
<tr>
<td>wrapperProps</td>
<td><code>&lt;object&gt;</code></td>
<td>The React properties for the wrapper component</td>
</tr>
</tbody>
</table>
<p><code>&lt;PositionType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>my</td>
<td><code>&lt;CornerType&gt;</code></td>
<td>The corner of the tip to position in relation to the <code>at</code> key</td>
</tr>
<tr>
<td>at</td>
<td><code>&lt;CornerType&gt;</code></td>
<td>The corner of <code>target</code> element to position the tip corner at</td>
</tr>
<tr>
<td>target</td>
<td><code>&lt;target-spec&gt;</code></td>
<td>The element the tip will be positioned in relation to. Can be one of <dl><dt>false</dt><dd>the source itself (default)</dd><dt>[&lt;number&gt;, &lt;number&gt;]</dt><dd>an array of x, y coordinates</dd><dt>&#39;mouse&#39;</dt><dd>the mouse coordinates for the event which triggered the tip to show</dd><dt>&lt;string&gt; \</td>
<td>DOMElement</dt><dd>CSS selector or React ref for another DOMElement</dd></dl></td>
</tr>
<tr>
<td>adjust</td>
<td><code>&lt;AdjustType&gt;</code></td>
<td>sub-configuration describing how the tip position should be adjusted</td>
</tr>
<tr>
<td>container</td>
<td>`<string> \</td>
<td>DOMElement`</td>
<td>CSS selector or React ref to the DOMElement under which tips will attached.</td>
</tr>
</tbody>
</table>
<p><code>&lt;CornerType&gt;</code> is one of the following enumeration value:</p>
<ul>
<li>top-left</li>
<li>top-center</li>
<li>top-right</li>
<li>center-left</li>
<li>center-right</li>
<li>bottom-left</li>
<li>bottom-center</li>
<li>bottom-right</li>
</ul>
<p><code>&lt;AdjustType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>mouse</td>
<td><code>&lt;mouse-spec&gt;</code></td>
<td>Describes how mouse movement affects the tip placement. Can be one of <dl><dt>false</dt><dd>do not adjust to mouse move (default)</dd><dt>true</dt><dd>adjust to mouse move</dd><dt><pre>function: event =&gt; ({ x, y })</pre></dt><dd>compute the position of the tip using a function which receives mouse move event as input</dd></dl></td>
</tr>
<tr>
<td>x</td>
<td><code>&lt;number&gt;</code></td>
<td>x-translation the tip (0 by default)</td>
</tr>
<tr>
<td>y</td>
<td><code>&lt;number&gt;</code></td>
<td>y-translation the tip (0 by default)</td>
</tr>
<tr>
<td>method</td>
<td><code>&lt;method-spec&gt;</code></td>
<td>Decribes the method to use to optimize tip placement inside its container. Can be one of <dl><dt>none</dt><dd>no placement adjustment (default)</dd><dt>{ flip: [&lt;CornerType&gt; (, &lt;CornerType&gt;)* ] }</dt><dd>pick the corner which maximizes overlap between the tip and its container</dd><dt>{ shift: [&lt;AxisType&gt; (, &lt;AxisType&gt;)*]}</dt><dd>keep the tip inside its container for the specified axis</dd></dl></td>
</tr>
</tbody>
</table>
<p><code>&lt;AxisType&gt;</code> is one of the following enumeration value:</p>
<ul>
<li>horizontal</li>
<li>vertical</li>
</ul>
<p><code>&lt;ShowType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>delay</td>
<td><code>&lt;number&gt;</code></td>
<td>Delay between mouse enter event in the source and the tip display (0ms by default)</td>
</tr>
</tbody>
</table>
<p><code>&lt;HideType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>delay</td>
<td><code>&lt;number&gt;</code></td>
<td>Delay between mouse leave event from the source or the tip and removal of the tip (0ms by default)</td>
</tr>
</tbody>
</table></div></div><div class="code"><div class="wrapper">  config: SourceConfig
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Read the config property from the <code>ConfigContext</code> React context</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> props =&gt; (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ConfigContext.Consumer</span>&gt;</span>
    {config =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">Storage</span> <span class="hljs-attribute">config</span>=<span class="hljs-value">{config}</span> {<span class="hljs-attribute">...props</span>} /&gt;</span>}
  <span class="hljs-tag">&lt;/<span class="hljs-title">ConfigContext.Consumer</span>&gt;</span>
)</span></div></div></div></div></body></html>