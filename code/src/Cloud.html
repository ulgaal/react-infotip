<!DOCTYPE html><html lang="en"><head><title>src/Cloud</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/Cloud"><meta name="groc-project-path" content="src/Cloud.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Cloud.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Copyright 2019 Ulrich Gaal</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<pre><code>http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<h1 id="cloud">Cloud</h1></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> React, { useRef, useState, useCallback, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>
<span class="hljs-keyword">import</span> { CornerType, TailType } <span class="hljs-keyword">from</span> <span class="hljs-string">'./prop-types'</span>
<span class="hljs-keyword">import</span> isEqual <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash.isequal'</span>
<span class="hljs-keyword">import</span> { styles } <span class="hljs-keyword">from</span> <span class="hljs-string">'./styles'</span>
<span class="hljs-keyword">import</span> CloudShape <span class="hljs-keyword">from</span> <span class="hljs-string">'./svg/CloudShape'</span>
<span class="hljs-keyword">import</span> useResizeObserver <span class="hljs-keyword">from</span> <span class="hljs-string">'./hooks/useResizeObserver'</span>
<span class="hljs-keyword">import</span> { GEOMETRY } <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers/sourceReducer'</span>
<span class="hljs-keyword">import</span> { log } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A <code>Cloud</code> component wraps another React component in
a cloud-shaped styleable wrapper.</p>
<p>Graphically a <code>Cloud</code> is composed of a cloud outline and a content.
The cloud shape is randomly computed using just a <code>folds</code> parameter
which indicates the number of folds the cloud <code>Cloud</code> have.</p>
<p>It has the following structure:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span> // div to position the cloud outline and the content using absolute positioning
 <span class="hljs-tag">&lt;<span class="hljs-title">SvgCloud</span>/&gt;</span> // Cloud outline
 <span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span> // Cloud content (overlaps the outline)
  ... tip content
 <span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span></code></pre></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> Cloud = ({
  children,
  my = <span class="hljs-string">'top-left'</span>,
  tail = {
    width: <span class="hljs-number">25</span>,
    height: <span class="hljs-number">25</span>
  },
  folds = <span class="hljs-number">13</span>,
  style = styles.defaultStyle,
  className,
  id,
  dispatch
}) =&gt; {
  <span class="hljs-keyword">const</span> props = { children, my, tail, folds, style, className, id, dispatch }
  log(<span class="hljs-string">'Cloud'</span>, <span class="hljs-number">0</span>, props)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A ResizeObserver is tied to the content <code>&lt;span&gt;</code> of the
<code>Cloud</code> to measure it precisely.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-literal">null</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A <code>Cloud</code> keeps track of a <code>metrics</code> state variable
which contains info extracted by processing the CSS style of
the <code>Cloud</code> and info extracted by measuring its content <code>&lt;span&gt;</code>.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> [metrics, setMetrics] = useState(<span class="hljs-literal">null</span>)

  <span class="hljs-keyword">const</span> measure = useCallback(entry =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Retrieve the dimensions of the content <code>&lt;span&gt;</code>
from the <code>ResizeObserver</code></p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> boundingClientRect = entry.target.getBoundingClientRect()
    <span class="hljs-keyword">const</span> innerSize = {
      width: boundingClientRect.width,
      height: boundingClientRect.height
    }
    <span class="hljs-keyword">const</span> newMetrics = computeMetrics({
      tail,
      folds,
      innerSize,
      style,
      className
    })
    <span class="hljs-keyword">if</span> (!isEqual(newMetrics, metrics)) {
      setMetrics(newMetrics)
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dispatch === <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">const</span> { corners, size } = newMetrics
        dispatch({ type: GEOMETRY, id, geometry: { corners, size } })
      }
    }
  }, [])
  useResizeObserver(ref, measure)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Update the metrics if tail, fold or innerSize change</p></div></div><div class="code"><div class="wrapper">  useEffect(() =&gt; {
    <span class="hljs-keyword">if</span> (metrics) {
      <span class="hljs-keyword">const</span> newMetrics = computeMetrics({
        tail,
        folds,
        innerSize: metrics.innerSize,
        style,
        className
      })
      <span class="hljs-keyword">if</span> (!isEqual(newMetrics, metrics)) {
        setMetrics(newMetrics)
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> dispatch === <span class="hljs-string">'function'</span>) {
          <span class="hljs-keyword">const</span> { corners, size } = newMetrics
          dispatch({ type: GEOMETRY, id, geometry: { corners, size } })
        }
      }
    }
  }, [tail, folds, style, className])

  <span class="hljs-keyword">let</span> containerStyle
  <span class="hljs-keyword">let</span> contentStyle
  <span class="hljs-keyword">if</span> (metrics) {
    <span class="hljs-keyword">const</span> {
      size: { width, height },
      delta
    } = metrics
    containerStyle = {
      visibility: <span class="hljs-string">'visible'</span>,
      width: <span class="hljs-string">`<span class="hljs-subst">${width}</span>px`</span>,
      height: <span class="hljs-string">`<span class="hljs-subst">${height}</span>px`</span>
    }
    contentStyle = {
      display: <span class="hljs-string">'inline-block'</span>,
      whiteSpace: <span class="hljs-string">'nowrap'</span>,
      position: <span class="hljs-string">'absolute'</span>,
      left: <span class="hljs-number">0.5</span> * delta,
      top: <span class="hljs-number">0.5</span> * delta,
      color: style.color,
      padding: style.padding
    }
  } <span class="hljs-keyword">else</span> {
    containerStyle = {
      visibility: <span class="hljs-string">'hidden'</span>
    }
    contentStyle = {
      display: <span class="hljs-string">'inline-block'</span>,
      padding: style.padding
    }
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">'rit-cloud'</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{containerStyle}</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">CloudShape</span> <span class="hljs-attribute">my</span>=<span class="hljs-value">{my}</span> <span class="hljs-attribute">metrics</span>=<span class="hljs-value">{metrics}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-title">span</span> <span class="hljs-attribute">ref</span>=<span class="hljs-value">{ref}</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{contentStyle}</span>&gt;</span>
        {children}
      <span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  )</span>
}

Cloud.propTypes = {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The corner of the cloud to which the tail attaches</p></div></div><div class="code"><div class="wrapper">  my: CornerType,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The size of the cloud tail</p></div></div><div class="code"><div class="wrapper">  tail: TailType,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The number of randomly generated cloud folds</p></div></div><div class="code"><div class="wrapper">  folds: PropTypes.number,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The CSS style to use to render the cloud</p></div></div><div class="code"><div class="wrapper">  style: PropTypes.object,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A dispatch function invoked when the geometry of the cloud changes.
The function receives a GEOMETRY action with the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>corners</td>
<td><code>&lt;CornersType&gt;</code></td>
<td>The position of the <code>Balloon</code>&#39;s tail end for all possible tail configurations.</td>
</tr>
<tr>
<td>size</td>
<td><code>&lt;SizeType&gt;</code></td>
<td>The size of the <code>Balloon</code>.</td>
</tr>
</tbody>
</table>
<p>CornersType</p>
<p><code>&lt;CornersType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>top-left</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to top-left.</td>
</tr>
<tr>
<td>top-center</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to top-center.</td>
</tr>
<tr>
<td>top-right</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to top-right.</td>
</tr>
<tr>
<td>center-left</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to center-left.</td>
</tr>
<tr>
<td>center-right</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to center-right.</td>
</tr>
<tr>
<td>bottom-left</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to top-left.</td>
</tr>
<tr>
<td>bottom-left</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to bottom-center.</td>
</tr>
<tr>
<td>bottom-center</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to top-left.</td>
</tr>
<tr>
<td>bottom-right</td>
<td><code>&lt;LocationType&gt;</code></td>
<td>The position of the wrapper&#39;s tail end when the <code>my</code> property is set to bottom-right.</td>
</tr>
</tbody>
</table>
<p><code>&lt;SizeType&gt;</code> is an object, which contains the following keys:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td><code>&lt;number&gt;</code></td>
<td>Width of the wrapper.</td>
</tr>
<tr>
<td>height</td>
<td><code>&lt;number&gt;</code></td>
<td>height of the wrapper.</td>
</tr>
</tbody>
</table></div></div><div class="code"><div class="wrapper">  dispatch: PropTypes.func,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><code>true</code> if the cloud is pinned to the screen</p></div></div><div class="code"><div class="wrapper">  pinned: PropTypes.bool,</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the cloud is contained in a <code>Storage</code>, an id which uniquely identifies
the <code>Source</code> to which this cloud belongs</p></div></div><div class="code"><div class="wrapper">  id: PropTypes.string
}

<span class="hljs-keyword">const</span> computeMetrics = ({ tail, folds, innerSize, style, className }) =&gt; {
  <span class="hljs-keyword">const</span> length = <span class="hljs-number">2</span> * (innerSize.width + innerSize.height)
  <span class="hljs-keyword">const</span> delta = (<span class="hljs-number">0.5</span> * length) / folds

  <span class="hljs-keyword">const</span> size = {
    width: innerSize.width + delta,
    height: innerSize.height + delta
  }
  <span class="hljs-keyword">return</span> {
    size,
    innerSize,
    corners: {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the coordinates of the tail tip for
all possible tail configurations, in local coordinates.
These coordinates must be passed to the <code>Engine</code> so that
precise tip placement can be computed.</p></div></div><div class="code"><div class="wrapper">      <span class="hljs-string">'top-left'</span>: {
        left: -tail.width,
        top: -tail.height
      },
      <span class="hljs-string">'top-center'</span>: {
        left: <span class="hljs-number">0.5</span> * size.width,
        top: -tail.height
      },
      <span class="hljs-string">'top-right'</span>: {
        left: size.width + tail.width,
        top: -tail.height
      },
      <span class="hljs-string">'center-left'</span>: {
        left: -tail.width,
        top: <span class="hljs-number">0.5</span> * size.height
      },
      <span class="hljs-string">'center-right'</span>: {
        left: size.width + tail.width,
        top: <span class="hljs-number">0.5</span> * size.height
      },
      <span class="hljs-string">'bottom-left'</span>: {
        left: -tail.width,
        top: size.height + tail.height
      },
      <span class="hljs-string">'bottom-center'</span>: {
        left: <span class="hljs-number">0.5</span> * size.width,
        top: size.height + tail.height
      },
      <span class="hljs-string">'bottom-right'</span>: {
        left: size.width + tail.width,
        top: size.height + tail.height
      }
    },
    tail,
    folds,
    delta,
    style,
    className
  }
}

<span class="hljs-keyword">const</span> areEqual = (prev, next) =&gt; {
  <span class="hljs-keyword">return</span> (
    prev.my === next.my &amp;&amp;
    prev.tail === next.tail &amp;&amp;
    prev.folds === next.folds &amp;&amp;
    prev.style === next.style &amp;&amp;
    prev.className === next.className &amp;&amp;
    prev.pinned === next.pinned &amp;&amp;
    prev.children === next.children
  )
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(Cloud, areEqual)</div></div></div></div></body></html>