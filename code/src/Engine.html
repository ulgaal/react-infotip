<!DOCTYPE html><html lang="en"><head><title>src/Engine</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/Engine"><meta name="groc-project-path" content="src/Engine.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Engine.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Copyright 2019 Ulrich Gaal</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<pre><code>http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<h1 id="engine">Engine</h1></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> { toRect, getElement, corner, surface, overlap } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>
<span class="hljs-keyword">import</span> isEqual <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash.isequal'</span>

const LEFT = new Set([
  <span class="hljs-string">'top-left'</span>,
  <span class="hljs-string">'center-left'</span>,
  <span class="hljs-string">'bottom-left'</span>,
  <span class="hljs-string">'top-center'</span>,
  <span class="hljs-string">'bottom-center'</span>
])
const RIGHT = new Set([
  <span class="hljs-string">'top-right'</span>,
  <span class="hljs-string">'center-right'</span>,
  <span class="hljs-string">'bottom-right'</span>,
  <span class="hljs-string">'top-center'</span>,
  <span class="hljs-string">'bottom-center'</span>
])
const TOP = new Set([
  <span class="hljs-string">'top-left'</span>,
  <span class="hljs-string">'top-center'</span>,
  <span class="hljs-string">'top-right'</span>,
  <span class="hljs-string">'center-right'</span>,
  <span class="hljs-string">'center-left'</span>
])
const BOTTOM = new Set([
  <span class="hljs-string">'bottom-left'</span>,
  <span class="hljs-string">'bottom-center'</span>,
  <span class="hljs-string">'bottom-right'</span>,
  <span class="hljs-string">'center-right'</span>,
  <span class="hljs-string">'center-left'</span>
])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>Engine</code> class provides common tip logic for the <code>Source</code>
and <code>Storage</code> class. It is responsible for tip timers and tip placement.
It is not a React component.
It receives DOM events from <code>Source</code> and <code>Storage</code> and transforms them into
higher level events that propagate to the engine output (either
a <code>Source</code> or a <code>Storage</code>):</p>
<ul>
<li><code>onLayoutChange</code> when the location of the tip changes.</li>
<li><code>onVisibilityChange</code> when the visibility of the tip changes.</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Engine</span> </span>{
  constructor (params) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Params has the following shape: { id, config, output }</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-built_in">Object</span>.assign(<span class="hljs-keyword">this</span>, params)
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>handleMouseOver</code> and <code>handleMouseOut</code> methods use
timers to determine when a tip should be made visible or hidden.</p></div></div><div class="code"><div class="wrapper">  handleMouseOver (event) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.pinned) {
      event.stopPropagation()
      <span class="hljs-keyword">const</span> {
        show: { delay },
        position: { target }
      } = <span class="hljs-keyword">this</span>.config
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hideTimeoutId) {
        clearInterval(<span class="hljs-keyword">this</span>.hideTimeoutId)
        <span class="hljs-keyword">this</span>.hideTimeoutId = <span class="hljs-literal">undefined</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.showTimeoutId = setTimeout(() =&gt; {
          <span class="hljs-keyword">this</span>.showTimeoutId = <span class="hljs-literal">undefined</span>
          <span class="hljs-keyword">this</span>.visible = <span class="hljs-literal">true</span>
          <span class="hljs-keyword">this</span>.output.onVisibilityChange({
            id: <span class="hljs-keyword">this</span>.id,
            visible: <span class="hljs-keyword">this</span>.visible,
            config: <span class="hljs-keyword">this</span>.config
          })
        }, delay)
        <span class="hljs-keyword">if</span> (target === <span class="hljs-string">'mouse'</span>) {
          <span class="hljs-keyword">this</span>.update({
            target: {
              left: event.clientX + <span class="hljs-built_in">window</span>.scrollX,
              top: event.clientY + <span class="hljs-built_in">window</span>.scrollY,
              width: <span class="hljs-number">1</span>,
              height: <span class="hljs-number">1</span>
            }
          })
        }
      }
    }
  }

  handleMouseOut (event) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.pinned) {
      <span class="hljs-keyword">if</span> (event) {
        event.stopPropagation()
      }
      <span class="hljs-keyword">const</span> {
        hide: { delay }
      } = <span class="hljs-keyword">this</span>.config
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.showTimeoutId) {
        clearInterval(<span class="hljs-keyword">this</span>.showTimeoutId)
        <span class="hljs-keyword">this</span>.showTimeoutId = <span class="hljs-literal">undefined</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.hideTimeoutId = setTimeout(() =&gt; {
          <span class="hljs-keyword">this</span>.hideTimeoutId = <span class="hljs-literal">undefined</span>
          <span class="hljs-keyword">this</span>.visible = <span class="hljs-literal">false</span>
          <span class="hljs-keyword">this</span>.output.onVisibilityChange({
            id: <span class="hljs-keyword">this</span>.id,
            visible: <span class="hljs-keyword">this</span>.visible,
            config: <span class="hljs-keyword">this</span>.config
          })
          <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.geometry
        }, delay)
      }
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>handleMouseMove</code> method handles tip placements
when the mouse tracking config key is set.</p></div></div><div class="code"><div class="wrapper">  handleMouseMove (event) {
    <span class="hljs-keyword">const</span> {
      position: {
        adjust: { mouse }
      }
    } = <span class="hljs-keyword">this</span>.config
    <span class="hljs-keyword">const</span> transform =
      <span class="hljs-keyword">typeof</span> mouse === <span class="hljs-string">'function'</span>
        ? mouse
        : event =&gt; ({
          x: event.clientX + <span class="hljs-built_in">window</span>.scrollX,
          y: event.clientY + <span class="hljs-built_in">window</span>.scrollY
        })
    <span class="hljs-keyword">const</span> { x, y } = transform(event)
    <span class="hljs-keyword">this</span>.update({
      target: {
        left: x,
        top: y,
        width: <span class="hljs-number">1</span>,
        height: <span class="hljs-number">1</span>
      }
    })
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>pin</code> method is used to force tip visibility or hiding.</p></div></div><div class="code"><div class="wrapper">  pin (pinned) {
    <span class="hljs-keyword">if</span> (pinned === <span class="hljs-keyword">this</span>.pinned) {
      <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.showTimeoutId) {
      clearInterval(<span class="hljs-keyword">this</span>.showTimeoutId)
      <span class="hljs-keyword">this</span>.showTimeoutId = <span class="hljs-literal">undefined</span>
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hideTimeoutId) {
      clearInterval(<span class="hljs-keyword">this</span>.hideTimeoutId)
      <span class="hljs-keyword">this</span>.hideTimeoutId = <span class="hljs-literal">undefined</span>
    }
    <span class="hljs-keyword">if</span> (pinned) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.visible) {
        <span class="hljs-keyword">this</span>.visible = <span class="hljs-literal">true</span>
        <span class="hljs-keyword">this</span>.output.onVisibilityChange({
          id: <span class="hljs-keyword">this</span>.id,
          visible: <span class="hljs-keyword">this</span>.visible,
          config: <span class="hljs-keyword">this</span>.config
        })
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.visible) {
        <span class="hljs-keyword">this</span>.handleMouseOut()
      }
    }
    <span class="hljs-keyword">this</span>.pinned = pinned
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The update method is invoked by <code>Source</code>, <code>Storage</code> or <code>Engine</code> itself
when a change occurs, which may have an impact on tip position.
There are three main possible changes:</p>
<ul>
<li><code>target</code> the source or its target changes.</li>
<li><code>geometry</code> the shape of the tip changes.</li>
<li><code>config</code> the config property changes.</li>
</ul></div></div><div class="code"><div class="wrapper">  update ({ target, geometry, config }) {
    <span class="hljs-keyword">const</span> { position } = <span class="hljs-keyword">this</span>.config
    <span class="hljs-keyword">const</span> updated = {}

    <span class="hljs-keyword">const</span> container = toRect(getElement(position.container))
    <span class="hljs-keyword">if</span> (!isEqual(container, <span class="hljs-keyword">this</span>.container)) {
      updated.container = container
    }

    <span class="hljs-keyword">if</span> (
      target &amp;&amp;
      ((target.nodeType === <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">this</span>.target !== target) ||
        !isEqual(target, <span class="hljs-keyword">this</span>.target))
    ) {
      updated.target = target
    }

    <span class="hljs-keyword">if</span> (config) {
      <span class="hljs-keyword">if</span> (!isEqual(config, <span class="hljs-keyword">this</span>.config)) {
        updated.config = config
      }
    }

    <span class="hljs-keyword">if</span> (geometry &amp;&amp; !isEqual(geometry, <span class="hljs-keyword">this</span>.geometry)) {
      updated.geometry = geometry
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(updated).length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">Object</span>.assign(<span class="hljs-keyword">this</span>, updated)
      <span class="hljs-keyword">this</span>.layout()
    }
  }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The layout method computes the actual tip placement, taking into account
the target shape, the tip shape and the container shape.</p></div></div><div class="code"><div class="wrapper">  layout () {
    <span class="hljs-keyword">const</span> { target, geometry, container } = <span class="hljs-keyword">this</span>
    <span class="hljs-keyword">if</span> (target &amp;&amp; geometry &amp;&amp; container) {
      <span class="hljs-keyword">const</span> {
        position: {
          at,
          my,
          adjust: { method, x, y }
        }
      } = <span class="hljs-keyword">this</span>.config
      <span class="hljs-keyword">const</span> { size, corners } = geometry
      <span class="hljs-keyword">const</span> target_ = target.nodeType === <span class="hljs-number">1</span> ? toRect(target) : target
      <span class="hljs-keyword">const</span> targetCorner = corner(target_, at)
      <span class="hljs-keyword">const</span> computeRect = my =&gt; {
        <span class="hljs-keyword">const</span> myCorner = corners[my]
        <span class="hljs-keyword">return</span> {
          left: target_.left + targetCorner.left - myCorner.left + x,
          top: target_.top + targetCorner.top - myCorner.top + y,
          ...size
        }
      }
      <span class="hljs-keyword">const</span> result = { my, location: computeRect(my) }
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> method === <span class="hljs-string">'object'</span>) {
        <span class="hljs-keyword">let</span> area = surface(overlap(container, result.location))
        <span class="hljs-keyword">if</span> (area &lt; surface(result.location)) {
          <span class="hljs-keyword">if</span> (method.flip) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> my <span class="hljs-keyword">of</span> method.flip) {
              <span class="hljs-keyword">const</span> location = computeRect(my)
              <span class="hljs-keyword">const</span> area_ = surface(overlap(container, location))
              <span class="hljs-keyword">if</span> (area_ &gt; area) {
                result.location = location
                result.my = my
                area = area_
              }
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.shift) {
            <span class="hljs-keyword">if</span> (method.shift.indexOf(<span class="hljs-string">'horizontal'</span>) !== -<span class="hljs-number">1</span>) {
              <span class="hljs-keyword">if</span> (LEFT.has(my)) {
                <span class="hljs-keyword">if</span> (
                  result.location.left + result.location.width &gt;
                  container.left + container.width
                ) {
                  result.location.left =
                    container.left + container.width - result.location.width
                }
              }
              <span class="hljs-keyword">if</span> (RIGHT.has(my)) {
                <span class="hljs-keyword">if</span> (result.location.left &lt; container.left) {
                  result.location.left = container.left
                }
              }
            }
            <span class="hljs-keyword">if</span> (method.shift.indexOf(<span class="hljs-string">'vertical'</span>) !== -<span class="hljs-number">1</span>) {
              <span class="hljs-keyword">if</span> (BOTTOM.has(my)) {
                <span class="hljs-keyword">if</span> (result.location.top &lt; container.top) {
                  result.location.top = container.top
                }
              }
              <span class="hljs-keyword">if</span> (TOP.has(my)) {
                <span class="hljs-keyword">if</span> (
                  result.location.top + result.location.height &gt;
                  container.top + container.height
                ) {
                  result.location.top =
                    container.top + container.height - result.location.height
                }
              }
            }
          }
        }
      }
      result.location.left -= container.left
      result.location.top -= container.top
      <span class="hljs-keyword">this</span>.output.onLayoutChange({
        id: <span class="hljs-keyword">this</span>.id,
        ...result,
        config: <span class="hljs-keyword">this</span>.config
      })
    }
  }
}</div></div></div></div></body></html>