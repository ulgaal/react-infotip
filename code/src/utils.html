<!DOCTYPE html><html lang="en"><head><title>src/utils</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/utils"><meta name="groc-project-path" content="src/utils.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/utils.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Copyright 2019 Ulrich Gaal</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<pre><code>http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
<h1 id="utilsjs">utils.js</h1></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> deepmerge <span class="hljs-keyword">from</span> <span class="hljs-string">'deepmerge'</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns the corner position of a rect</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> corner = (dimensions, position) =&gt; {
  <span class="hljs-keyword">const</span> { width = <span class="hljs-number">0</span>, height = <span class="hljs-number">0</span> } = dimensions
  <span class="hljs-keyword">switch</span> (position) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'top-left'</span>:
      <span class="hljs-keyword">return</span> {
        left: <span class="hljs-number">0</span>,
        top: <span class="hljs-number">0</span>
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'top-center'</span>:
      <span class="hljs-keyword">return</span> {
        left: width * <span class="hljs-number">0.5</span>,
        top: <span class="hljs-number">0</span>
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'top-right'</span>:
      <span class="hljs-keyword">return</span> {
        left: width,
        top: <span class="hljs-number">0</span>
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'center-left'</span>:
      <span class="hljs-keyword">return</span> {
        left: <span class="hljs-number">0</span>,
        top: height * <span class="hljs-number">0.5</span>
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'center-right'</span>:
      <span class="hljs-keyword">return</span> {
        left: width,
        top: height * <span class="hljs-number">0.5</span>
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'bottom-left'</span>:
      <span class="hljs-keyword">return</span> {
        left: <span class="hljs-number">0</span>,
        top: height
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'bottom-center'</span>:
      <span class="hljs-keyword">return</span> {
        left: width * <span class="hljs-number">0.5</span>,
        top: height
      }
    <span class="hljs-keyword">case</span> <span class="hljs-string">'bottom-right'</span>:
      <span class="hljs-keyword">return</span> {
        left: width,
        top: height
      }
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Unknown position <span class="hljs-subst">${position}</span>`</span>, position)
  }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the overlap of two rects</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> overlap = (r1, r2) =&gt; ({
  width: <span class="hljs-built_in">Math</span>.max(
    <span class="hljs-number">0</span>,
    <span class="hljs-built_in">Math</span>.min(r1.left + r1.width, r2.left + r2.width) -
      <span class="hljs-built_in">Math</span>.max(r1.left, r2.left)
  ),
  height: <span class="hljs-built_in">Math</span>.max(
    <span class="hljs-number">0</span>,
    <span class="hljs-built_in">Math</span>.min(r1.top + r1.height, r2.top + r2.height) - <span class="hljs-built_in">Math</span>.max(r1.top, r2.top)
  )
})</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the surface of a rect</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> surface = ({ width, height }) =&gt; width * height</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Read a property from an object</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getProperty = (obj, path) =&gt;
  path
    .split(<span class="hljs-string">'.'</span>)
    .reduce(
      (obj, prop) =&gt; (obj &amp;&amp; obj.hasOwnProperty(prop) ? obj[prop] : <span class="hljs-literal">null</span>),
      obj
    )</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Appends the <code>px</code> suffix to the values of an object</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> pixelize = obj =&gt;
  <span class="hljs-built_in">Object</span>.entries(obj || {}).reduce((obj, [key, value]) =&gt; {
    obj[key] = <span class="hljs-string">`<span class="hljs-subst">${value}</span>px`</span>
    <span class="hljs-keyword">return</span> obj
  }, {})</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Merge two objects</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mergeObjects = (obj1, obj2) =&gt; deepmerge(obj1 || {}, obj2 || {})</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Converts a graph into map. The map keys are path to the graph node,
the map values are the node values</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> toProps = (obj, props = {}, prefix = <span class="hljs-string">''</span>) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(obj) &amp;&amp; obj.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) {
      toProps(value, props, <span class="hljs-string">`<span class="hljs-subst">${prefix}</span>[<span class="hljs-subst">${key}</span>]`</span>)
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (
    obj !== <span class="hljs-literal">null</span> &amp;&amp;
    <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">'object'</span> &amp;&amp;
    !(obj <span class="hljs-keyword">instanceof</span> Element)
  ) {
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(obj).length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) {
        toProps(value, props, prefix ? <span class="hljs-string">`<span class="hljs-subst">${prefix}</span>.<span class="hljs-subst">${key}</span>`</span> : key)
      }
    } <span class="hljs-keyword">else</span> {
      props[prefix] = <span class="hljs-built_in">Array</span>.isArray(obj) ? [] : {}
    }
  } <span class="hljs-keyword">else</span> {
    props[prefix] = obj
  }
  <span class="hljs-keyword">return</span> props
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Converts a map into a graph. The map keys are path to the graph node,
the map values are the node values</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> fromProps = props =&gt; {
  <span class="hljs-keyword">const</span> consume = ({ fringe, visited }) =&gt;
    <span class="hljs-built_in">Object</span>.entries(fringe).reduce(
      ({ fringe, visited }, [key, value]) =&gt; {
        <span class="hljs-keyword">const</span> arrayMatch = <span class="hljs-regexp">/^(.+)?\[(\d+)]$/</span>.exec(key)
        <span class="hljs-keyword">if</span> (arrayMatch) {
          <span class="hljs-keyword">const</span> [, parentKey = <span class="hljs-string">''</span>, index] = arrayMatch
          <span class="hljs-keyword">let</span> array = visited[parentKey]
          <span class="hljs-keyword">if</span> (!array) {
            fringe[parentKey] = visited[parentKey] = array = []
          }
          array[index] = value
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">const</span> objMatch = <span class="hljs-regexp">/^(?:(.+)\.)?([^[.]+)$/</span>.exec(key)
          <span class="hljs-keyword">if</span> (objMatch) {
            <span class="hljs-keyword">const</span> [, parentKey = <span class="hljs-string">''</span>, prop] = objMatch
            <span class="hljs-keyword">let</span> object = visited[parentKey]
            <span class="hljs-keyword">if</span> (!object) {
              fringe[parentKey] = visited[parentKey] = object = {}
            }
            object[prop] = value
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">''</span> &amp;&amp; !visited.hasOwnProperty(key)) {
            visited[key] = value
          }
        }
        <span class="hljs-keyword">return</span> { fringe, visited }
      },
      {
        fringe: {},
        visited: { ...visited }
      }
    )
  <span class="hljs-keyword">let</span> step = { fringe: props, visited: {} }
  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Object</span>.keys(step.fringe).length &gt; <span class="hljs-number">0</span>) {
    step = consume(step)
  }
  <span class="hljs-keyword">return</span> step.visited[<span class="hljs-string">''</span>]
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Compute the bounding rect of a DOMElement</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> toRect = element =&gt; {
  <span class="hljs-keyword">const</span> rect = element
    ? element.getBoundingClientRect()
    : { left: <span class="hljs-number">0</span>, top: <span class="hljs-number">0</span>, width: <span class="hljs-number">0</span>, height: <span class="hljs-number">0</span> }
  <span class="hljs-keyword">const</span> { left, top, width, height } = rect
  <span class="hljs-keyword">return</span> {
    left: left + <span class="hljs-built_in">window</span>.scrollX,
    top: top + <span class="hljs-built_in">window</span>.scrollY,
    width,
    height
  }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns the DOMElement specified by the value (or the document <code>&lt;body&gt;</code> if no value is specified)</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getElement = value =&gt; {
  <span class="hljs-keyword">if</span> (!value) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.body
  }
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.querySelector(value)
  }
  <span class="hljs-keyword">return</span> value
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Returns true if two Sets are equal</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> eqSet = (<span class="hljs-keyword">as</span>, bs) =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">as</span>.size !== bs.size) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> a <span class="hljs-keyword">of</span> <span class="hljs-keyword">as</span>) {
    <span class="hljs-keyword">if</span> (!bs.has(a)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Substracts two Sets.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> diffSet = (<span class="hljs-keyword">as</span>, bs) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([...as].filter(obj =&gt; !bs.has(obj)))</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>A sequence generator function</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">seq</span>(<span class="hljs-params">start, end</span>) </span>{
  <span class="hljs-keyword">if</span> (start &lt; end) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> current = start; current &lt; end; current++) {
      <span class="hljs-keyword">yield</span> current
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> current = start; current &gt; end; current--) {
      <span class="hljs-keyword">yield</span> current
    }
  }
}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Binds a set of methods to the specified target</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> autobind = (methods, target) =&gt;
  methods.forEach(method =&gt; {
    target[method] = target[method].bind(target)
  })</div></div></div></div></body></html>